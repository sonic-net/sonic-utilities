"""
Autogenerated config CLI plugin.
"""

import copy
import click
import utilities_common.cli as clicommon
import utilities_common.general as general
from config import config_mgmt


# Load sonic-cfggen from source since /usr/local/bin/sonic-cfggen does not have .py extension.
sonic_cfggen = general.load_module_from_source('sonic_cfggen', '/usr/local/bin/sonic-cfggen')


def exit_with_error(*args, **kwargs):
    """ Print a message with click.secho and abort CLI.

    Args:
        args: Positional arguments to pass to click.secho
        kwargs: Keyword arguments to pass to click.secho
    """

    click.secho(*args, **kwargs)
    raise click.Abort()


def validate_config_or_raise(cfg):
    """ Validate config db data using ConfigMgmt.

    Args:
        cfg (Dict): Config DB data to validate.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    try:
        cfg = sonic_cfggen.FormatConverter.to_serialized(copy.deepcopy(cfg))
        config_mgmt.ConfigMgmt().loadData(cfg)
    except Exception as err:
        raise Exception('Failed to validate configuration: {}'.format(err))


def add_entry_validated(db, table, key, data):
    """ Add new entry in table and validate configuration.

    Args:
        db (swsscommon.ConfigDBConnector): Config DB connector obect.
        table (str): Table name to add new entry to.
        key (Union[str, Tuple]): Key name in the table.
        data (Dict): Entry data.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    cfg = db.get_config()
    cfg.setdefault(table, {})
    if key in cfg[table]:
        raise Exception(f"{key} already exists")

    cfg[table][key] = data

    validate_config_or_raise(cfg)
    db.set_entry(table, key, data)


def update_entry_validated(db, table, key, data, create_if_not_exists=False):
    """ Update entry in table and validate configuration.
    If attribute value in data is None, the attribute is deleted.

    Args:
        db (swsscommon.ConfigDBConnector): Config DB connector obect.
        table (str): Table name to add new entry to.
        key (Union[str, Tuple]): Key name in the table.
        data (Dict): Entry data.
        create_if_not_exists (bool):
            In case entry does not exists already a new entry
            is not created if this flag is set to False and
            creates a new entry if flag is set to True.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    cfg = db.get_config()
    cfg.setdefault(table, {})

    if not data:
        raise Exception(f"No field/values to update {key}")

    if create_if_not_exists:
        cfg[table].setdefault(key, {})

    if key not in cfg[table]:
        raise Exception(f"{key} does not exist")

    entry_changed = False
    for attr, value in data.items():
        if value == cfg[table][key].get(attr):
            continue
        entry_changed = True
        if value is None:
            cfg[table][key].pop(attr, None)
        else:
            cfg[table][key][attr] = value

    if not entry_changed:
        return

    validate_config_or_raise(cfg)
    db.set_entry(table, key, cfg[table][key])


def del_entry_validated(db, table, key):
    """ Delete entry in table and validate configuration.

    Args:
        db (swsscommon.ConfigDBConnector): Config DB connector obect.
        table (str): Table name to add new entry to.
        key (Union[str, Tuple]): Key name in the table.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    cfg = db.get_config()
    cfg.setdefault(table, {})
    if key not in cfg[table]:
        raise Exception(f"{key} does not exist")

    cfg[table].pop(key)

    validate_config_or_raise(cfg)
    db.set_entry(table, key, None)


def add_list_entry_validated(db, table, key, attr, data):
    """ Add new entry into list in table and validate configuration.

    Args:
        db (swsscommon.ConfigDBConnector): Config DB connector obect.
        table (str): Table name to add data to.
        key (Union[str, Tuple]): Key name in the table.
        attr (str): Attribute name which represents a list the data needs to be added to.
        data (List): Data list to add to config DB.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    cfg = db.get_config()
    cfg.setdefault(table, {})
    if key not in cfg[table]:
        raise Exception(f"{key} does not exist")
    cfg[table][key].setdefault(attr, [])
    for entry in data:
        if entry in cfg[table][key][attr]:
            raise Exception(f"{entry} already exists")
        cfg[table][key][attr].append(entry)

    validate_config_or_raise(cfg)
    db.set_entry(table, key, cfg[table][key])


def del_list_entry_validated(db, table, key, attr, data):
    """ Delete entry from list in table and validate configuration.

    Args:
        db (swsscommon.ConfigDBConnector): Config DB connector obect.
        table (str): Table name to remove data from.
        key (Union[str, Tuple]): Key name in the table.
        attr (str): Attribute name which represents a list the data needs to be removed from.
        data (Dict): Data list to remove from config DB.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    cfg = db.get_config()
    cfg.setdefault(table, {})
    if key not in cfg[table]:
        raise Exception(f"{key} does not exist")
    cfg[table][key].setdefault(attr, [])
    for entry in data:
        if entry not in cfg[table][key][attr]:
            raise Exception(f"{entry} does not exist")
        cfg[table][key][attr].remove(entry)
    if not cfg[table][key][attr]:
        cfg[table][key].pop(attr)

    validate_config_or_raise(cfg)
    db.set_entry(table, key, cfg[table][key])


def clear_list_entry_validated(db, table, key, attr):
    """ Clear list in object and validate configuration.

    Args:
        db (swsscommon.ConfigDBConnector): Config DB connector obect.
        table (str): Table name to remove the list attribute from.
        key (Union[str, Tuple]): Key name in the table.
        attr (str): Attribute name which represents a list that needs to be removed.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    update_entry_validated(db, table, key, {attr: None})


@click.group(name="fg-nhg",
             cls=clicommon.AliasedGroup)
def FG_NHG():
    """ FG_NHG part of config_db.json """

    pass


@FG_NHG.command(name="add")
@click.argument(
    "name",
    nargs=1,
    required=True,
)
@click.option(
    "--bucket-size",
    help="total hash bucket size desired, recommended value of Lowest Common Multiple of \
          1..max-next-hops.[mandatory]",
)
@click.option(
    "--match-mode",
    help="The filtering method used to identify when to use Fine Grained vs regular route handling. \
          -- nexthop-based filters on nexthop IPs only. \
          -- route-based filters on both prefix and nexthop IPs. \
          -- prefix-based filters on prefix only.[mandatory]",
)
@click.option(
    "--max-next-hops",
    help="Applicable only for match_mode = prefix-based. Maximum number of nexthops that will be \
          received in route updates for any of the prefixes that match FG_NHG_PREFIX for \
          this FG_NHG.[mandatory]",
)
@clicommon.pass_db
def FG_NHG_add(db, name, bucket_size, match_mode, max_next_hops):
    """ Add object in FG_NHG. """

    table = "FG_NHG"
    key = name
    data = {}
    if bucket_size is not None:
        data["bucket_size"] = bucket_size
    if match_mode is not None:
        data["match_mode"] = match_mode
    if max_next_hops is not None:
        data["max_next_hops"] = max_next_hops

    try:
        add_entry_validated(db.cfgdb, table, key, data)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@FG_NHG.command(name="update")
@click.argument(
    "name",
    nargs=1,
    required=True,
)
@click.option(
    "--bucket-size",
    help="total hash bucket size desired, recommended value is Lowest Common Multiple of \
          1..max-next-hops[mandatory]",
)
@click.option(
    "--match-mode",
    help="The filtering method used to identify when to use Fine Grained vs regular route handling. \
          -- nexthop-based filters on nexthop IPs only. \
          -- route-based filters on both prefix and nexthop IPs. \
          -- prefix-based filters on prefix only.[mandatory]",
)
@click.option(
    "--max-next-hops",
    help="Applicable only for match_mode = prefix-based. Maximum number of nexthops that will be \
          received in route updates for any of the prefixes that match FG_NHG_PREFIX for this FG_NHG.[mandatory]",
)
@clicommon.pass_db
def FG_NHG_update(db, name, bucket_size, match_mode, max_next_hops):
    """ Add object in FG_NHG. """

    table = "FG_NHG"
    key = name
    data = {}
    if bucket_size is not None:
        data["bucket_size"] = bucket_size
    if match_mode is not None:
        data["match_mode"] = match_mode
    if max_next_hops is not None:
        data["max_next_hops"] = max_next_hops

    try:
        update_entry_validated(db.cfgdb, table, key, data)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@FG_NHG.command(name="delete")
@click.argument(
    "name",
    nargs=1,
    required=True,
)
@clicommon.pass_db
def FG_NHG_delete(db, name):
    """ Delete object in FG_NHG. """

    table = "FG_NHG"
    key = name
    try:
        del_entry_validated(db.cfgdb, table, key)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@click.group(name="fg-nhg-prefix",
             cls=clicommon.AliasedGroup)
def FG_NHG_PREFIX():
    """ FG_NHG_PREFIX part of config_db.json """

    pass


@FG_NHG_PREFIX.command(name="add")
@click.argument(
    "ip-prefix",
    nargs=1,
    required=True,
)
@click.option(
    "--fg-nhg",
    help="Fine Grained next-hop group name[mandatory]",
)
@clicommon.pass_db
def FG_NHG_PREFIX_add(db, ip_prefix, fg_nhg):
    """ Add object in FG_NHG_PREFIX. """

    table = "FG_NHG_PREFIX"
    key = ip_prefix
    data = {}
    if fg_nhg is not None:
        data["FG_NHG"] = fg_nhg

    try:
        add_entry_validated(db.cfgdb, table, key, data)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@FG_NHG_PREFIX.command(name="update")
@click.argument(
    "ip-prefix",
    nargs=1,
    required=True,
)
@click.option(
    "--fg-nhg",
    help="Fine Grained next-hop group name[mandatory]",
)
@clicommon.pass_db
def FG_NHG_PREFIX_update(db, ip_prefix, fg_nhg):
    """ Add object in FG_NHG_PREFIX. """

    table = "FG_NHG_PREFIX"
    key = ip_prefix
    data = {}
    if fg_nhg is not None:
        data["FG_NHG"] = fg_nhg

    try:
        update_entry_validated(db.cfgdb, table, key, data)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@FG_NHG_PREFIX.command(name="delete")
@click.argument(
    "ip-prefix",
    nargs=1,
    required=True,
)
@clicommon.pass_db
def FG_NHG_PREFIX_delete(db, ip_prefix):
    """ Delete object in FG_NHG_PREFIX. """

    table = "FG_NHG_PREFIX"
    key = ip_prefix
    try:
        del_entry_validated(db.cfgdb, table, key)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@click.group(name="fg-nhg-member",
             cls=clicommon.AliasedGroup)
def FG_NHG_MEMBER():
    """ FG_NHG_MEMBER part of config_db.json """

    pass


@FG_NHG_MEMBER.command(name="add")
@click.argument(
    "next-hop-ip",
    nargs=1,
    required=True,
)
@click.option(
    "--fg-nhg",
    help="Fine Grained next-hop group name[mandatory]",
)
@click.option(
    "--bank",
    help="An index which specifies a bank/group in which the redistribution is performed[mandatory]",
)
@click.option(
    "--link",
    help="Link associated with next-hop-ip, if configured, enables next-hop withdrawal/addition \
          per link's operational state changes",
)
@clicommon.pass_db
def FG_NHG_MEMBER_add(db, next_hop_ip, fg_nhg, bank, link):
    """ Add object in FG_NHG_MEMBER. """

    table = "FG_NHG_MEMBER"
    key = next_hop_ip
    data = {}
    if fg_nhg is not None:
        data["FG_NHG"] = fg_nhg
    if bank is not None:
        data["bank"] = bank
    if link is not None:
        data["link"] = link

    try:
        add_entry_validated(db.cfgdb, table, key, data)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@FG_NHG_MEMBER.command(name="update")
@click.argument(
    "next-hop-ip",
    nargs=1,
    required=True,
)
@click.option(
    "--fg-nhg",
    help="Fine Grained next-hop group name[mandatory]",
)
@click.option(
    "--bank",
    help="An index which specifies a bank/group in which the redistribution is performed[mandatory]",
)
@click.option(
    "--link",
    help="Link associated with next-hop-ip, if configured, enables next-hop withdrawal/addition \
          per link's operational state changes",
)
@clicommon.pass_db
def FG_NHG_MEMBER_update(db, next_hop_ip, fg_nhg, bank, link):
    """ Add object in FG_NHG_MEMBER. """

    table = "FG_NHG_MEMBER"
    key = next_hop_ip
    data = {}
    if fg_nhg is not None:
        data["FG_NHG"] = fg_nhg
    if bank is not None:
        data["bank"] = bank
    if link is not None:
        data["link"] = link

    try:
        update_entry_validated(db.cfgdb, table, key, data)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@FG_NHG_MEMBER.command(name="delete")
@click.argument(
    "next-hop-ip",
    nargs=1,
    required=True,
)
@clicommon.pass_db
def FG_NHG_MEMBER_delete(db, next_hop_ip):
    """ Delete object in FG_NHG_MEMBER. """

    table = "FG_NHG_MEMBER"
    key = next_hop_ip
    try:
        del_entry_validated(db.cfgdb, table, key)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


def register(cli):
    """ Register new CLI nodes in root CLI.

    Args:
        cli: Root CLI node.
    Raises:
        Exception: when root CLI already has a command
                   we are trying to register.
    """
    cli_nodes = [FG_NHG, FG_NHG_PREFIX, FG_NHG_MEMBER]
    for cli_node in cli_nodes:
        if cli_node.name in cli.commands:
            raise Exception(f"{cli_node.name} already exists in CLI")
        cli.add_command(cli_node)
