"""
Autogenerated config CLI plugin.


"""

import copy
import click
import utilities_common.cli as clicommon
import utilities_common.general as general
from config import config_mgmt


# Load sonic-cfggen from source since /usr/local/bin/sonic-cfggen does not have .py extension.
sonic_cfggen = general.load_module_from_source('sonic_cfggen', '/usr/local/bin/sonic-cfggen')


def exit_with_error(*args, **kwargs):
    """ Print a message with click.secho and abort CLI.

    Args:
        args: Positional arguments to pass to click.secho
        kwargs: Keyword arguments to pass to click.secho
    """

    click.secho(*args, **kwargs)
    raise click.Abort()


def validate_config_or_raise(cfg):
    """ Validate config db data using ConfigMgmt.

    Args:
        cfg (Dict): Config DB data to validate.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    try:
        cfg = sonic_cfggen.FormatConverter.to_serialized(copy.deepcopy(cfg))
        config_mgmt.ConfigMgmt().loadData(cfg)
    except Exception as err:
        raise Exception('Failed to validate configuration: {}'.format(err))


def add_entry_validated(db, table, key, data):
    """ Add new entry in table and validate configuration.

    Args:
        db (swsscommon.ConfigDBConnector): Config DB connector obect.
        table (str): Table name to add new entry to.
        key (Union[str, Tuple]): Key name in the table.
        data (Dict): Entry data.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    cfg = db.get_config()
    cfg.setdefault(table, {})
    if key in cfg[table]:
        raise Exception(f"{key} already exists")

    cfg[table][key] = data

    validate_config_or_raise(cfg)
    db.set_entry(table, key, data)


def update_entry_validated(db, table, key, data, create_if_not_exists=False):
    """ Update entry in table and validate configuration.
    If attribute value in data is None, the attribute is deleted.

    Args:
        db (swsscommon.ConfigDBConnector): Config DB connector obect.
        table (str): Table name to add new entry to.
        key (Union[str, Tuple]): Key name in the table.
        data (Dict): Entry data.
        create_if_not_exists (bool):
            In case entry does not exists already a new entry
            is not created if this flag is set to False and
            creates a new entry if flag is set to True.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    cfg = db.get_config()
    cfg.setdefault(table, {})

    if not data:
        raise Exception(f"No field/values to update {key}")

    if create_if_not_exists:
        cfg[table].setdefault(key, {})

    if key not in cfg[table]:
        raise Exception(f"{key} does not exist")

    entry_changed = False
    for attr, value in data.items():
        if value == cfg[table][key].get(attr):
            continue
        entry_changed = True
        if value is None:
            cfg[table][key].pop(attr, None)
        else:
            cfg[table][key][attr] = value

    if not entry_changed:
        return

    validate_config_or_raise(cfg)
    db.set_entry(table, key, cfg[table][key])


def del_entry_validated(db, table, key):
    """ Delete entry in table and validate configuration.

    Args:
        db (swsscommon.ConfigDBConnector): Config DB connector obect.
        table (str): Table name to add new entry to.
        key (Union[str, Tuple]): Key name in the table.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    cfg = db.get_config()
    cfg.setdefault(table, {})
    if key not in cfg[table]:
        raise Exception(f"{key} does not exist")

    cfg[table].pop(key)

    validate_config_or_raise(cfg)
    db.set_entry(table, key, None)


def add_list_entry_validated(db, table, key, attr, data):
    """ Add new entry into list in table and validate configuration.

    Args:
        db (swsscommon.ConfigDBConnector): Config DB connector obect.
        table (str): Table name to add data to.
        key (Union[str, Tuple]): Key name in the table.
        attr (str): Attribute name which represents a list the data needs to be added to.
        data (List): Data list to add to config DB.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    cfg = db.get_config()
    cfg.setdefault(table, {})
    if key not in cfg[table]:
        raise Exception(f"{key} does not exist")
    cfg[table][key].setdefault(attr, [])
    for entry in data:
        if entry in cfg[table][key][attr]:
            raise Exception(f"{entry} already exists")
        cfg[table][key][attr].append(entry)

    validate_config_or_raise(cfg)
    db.set_entry(table, key, cfg[table][key])


def del_list_entry_validated(db, table, key, attr, data):
    """ Delete entry from list in table and validate configuration.

    Args:
        db (swsscommon.ConfigDBConnector): Config DB connector obect.
        table (str): Table name to remove data from.
        key (Union[str, Tuple]): Key name in the table.
        attr (str): Attribute name which represents a list the data needs to be removed from.
        data (Dict): Data list to remove from config DB.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    cfg = db.get_config()
    cfg.setdefault(table, {})
    if key not in cfg[table]:
        raise Exception(f"{key} does not exist")
    cfg[table][key].setdefault(attr, [])
    for entry in data:
        if entry not in cfg[table][key][attr]:
            raise Exception(f"{entry} does not exist")
        cfg[table][key][attr].remove(entry)
    if not cfg[table][key][attr]:
        cfg[table][key].pop(attr)

    validate_config_or_raise(cfg)
    db.set_entry(table, key, cfg[table][key])


def clear_list_entry_validated(db, table, key, attr):
    """ Clear list in object and validate configuration.

    Args:
        db (swsscommon.ConfigDBConnector): Config DB connector obect.
        table (str): Table name to remove the list attribute from.
        key (Union[str, Tuple]): Key name in the table.
        attr (str): Attribute name which represents a list that needs to be removed.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    update_entry_validated(db, table, key, {attr: None})


@click.group(name="dhcpv4-relay",
             cls=clicommon.AliasedGroup)
def DHCPV4_RELAY():
    """ DHCPV4_RELAY part of config_db.json """

    pass


@DHCPV4_RELAY.command(name="add")
@click.argument(
    "name",
    nargs=1,
    required=True,
)
@click.option(
    "--server-vrf",
    help="Server VRF",
)
@click.option(
    "--source-interface",
    help="Used to determine the source IP address of the relayed packet",
)
@click.option(
    "--link-selection",
    help="Enable link selection",
)
@click.option(
    "--vrf-selection",
    help="Enable VRF selection",
)
@click.option(
    "--server-id-override",
    help="Enable server id override",
)
@click.option(
    "--agent-relay-mode",
    help="How to forward packets that already have a relay option",
)
@click.option(
    "--max-hop-count",
    help="Maximum hop count for relayed packets",
)
@click.option(
    "--dhcpv4-servers",
    help="Server IPv4 address list",
)
@clicommon.pass_db
def DHCPV4_RELAY_add(db, name, server_vrf, source_interface, link_selection, vrf_selection,
                     server_id_override, agent_relay_mode, max_hop_count, dhcpv4_servers):
    """ Add object in DHCPV4_RELAY. """

    table = "DHCPV4_RELAY"
    key = name
    data = {}
    if server_vrf is not None:
        data["server_vrf"] = server_vrf
    if source_interface is not None:
        data["source_interface"] = source_interface
    if link_selection is not None:
        data["link_selection"] = link_selection
    if vrf_selection is not None:
        data["vrf_selection"] = vrf_selection
    if server_id_override is not None:
        data["server_id_override"] = server_id_override
    if agent_relay_mode is not None:
        data["agent_relay_mode"] = agent_relay_mode
    if max_hop_count is not None:
        data["max_hop_count"] = max_hop_count
    if dhcpv4_servers is not None:
        data["dhcpv4_servers"] = dhcpv4_servers.split(",")

    try:
        add_entry_validated(db.cfgdb, table, key, data)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@DHCPV4_RELAY.command(name="update")
@click.argument(
    "name",
    nargs=1,
    required=True,
)
@click.option(
    "--server-vrf",
    help="Server VRF",
)
@click.option(
    "--source-interface",
    help="Used to determine the source IP address of the relayed packet",
)
@click.option(
    "--link-selection",
    help="Enable link selection",
)
@click.option(
    "--vrf-selection",
    help="Enable VRF selection",
)
@click.option(
    "--server-id-override",
    help="Enable server id override",
)
@click.option(
    "--agent-relay-mode",
    help="How to forward packets that already have a relay option",
)
@click.option(
    "--max-hop-count",
    help="Maximum hop count for relayed packets",
)
@click.option(
    "--dhcpv4-servers",
    help="Server IPv4 address list",
)
@clicommon.pass_db
def DHCPV4_RELAY_update(db, name, server_vrf, source_interface, link_selection, vrf_selection,
                        server_id_override, agent_relay_mode, max_hop_count, dhcpv4_servers):
    """ Add object in DHCPV4_RELAY. """

    table = "DHCPV4_RELAY"
    key = name
    data = {}
    if server_vrf is not None:
        data["server_vrf"] = server_vrf
    if source_interface is not None:
        data["source_interface"] = source_interface
    if link_selection is not None:
        data["link_selection"] = link_selection
    if vrf_selection is not None:
        data["vrf_selection"] = vrf_selection
    if server_id_override is not None:
        data["server_id_override"] = server_id_override
    if agent_relay_mode is not None:
        data["agent_relay_mode"] = agent_relay_mode
    if max_hop_count is not None:
        data["max_hop_count"] = max_hop_count
    if dhcpv4_servers is not None:
        data["dhcpv4_servers"] = dhcpv4_servers.split(",")

    try:
        update_entry_validated(db.cfgdb, table, key, data)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@DHCPV4_RELAY.command(name="delete")
@click.argument(
    "name",
    nargs=1,
    required=True,
)
@clicommon.pass_db
def DHCPV4_RELAY_delete(db, name):
    """ Delete object in DHCPV4_RELAY. """

    table = "DHCPV4_RELAY"
    key = name
    try:
        del_entry_validated(db.cfgdb, table, key)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@DHCPV4_RELAY.group(name="dhcpv4-servers",
                    cls=clicommon.AliasedGroup)
def DHCPV4_RELAY_dhcpv4_servers():
    """ Add/Delete dhcpv4_servers in DHCPV4_RELAY """

    pass


@DHCPV4_RELAY_dhcpv4_servers.command(name="add")
@click.argument(
    "name",
    nargs=1,
    required=True,
)
@click.argument(
    "dhcpv4-servers",
    nargs=-1,
    required=True,
)
@clicommon.pass_db
def DHCPV4_RELAY_dhcpv4_servers_add(
    db,
    name, dhcpv4_servers
):
    """ Add dhcpv4_servers in DHCPV4_RELAY """

    table = "DHCPV4_RELAY"
    key = name
    attr = "dhcpv4_servers"
    data = dhcpv4_servers

    try:
        add_list_entry_validated(db.cfgdb, table, key, attr, data)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@DHCPV4_RELAY_dhcpv4_servers.command(name="delete")
@click.argument(
    "name",
    nargs=1,
    required=True,
)
@click.argument(
    "dhcpv4-servers",
    nargs=-1,
    required=True,
)
@clicommon.pass_db
def DHCPV4_RELAY_dhcpv4_servers_delete(
    db,
    name, dhcpv4_servers
):
    """ Delete dhcpv4_servers in DHCPV4_RELAY """

    table = "DHCPV4_RELAY"
    key = name
    attr = "dhcpv4_servers"
    data = dhcpv4_servers

    try:
        del_list_entry_validated(db.cfgdb, table, key, attr, data)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@DHCPV4_RELAY_dhcpv4_servers.command(name="clear")
@click.argument(
    "name",
    nargs=1,
    required=True,
)
@clicommon.pass_db
def DHCPV4_RELAY_dhcpv4_servers_clear(
    db,
    name
):
    """ Clear dhcpv4_servers in DHCPV4_RELAY """

    table = "DHCPV4_RELAY"
    key = name
    attr = "dhcpv4_servers"

    try:
        clear_list_entry_validated(db.cfgdb, table, key, attr)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


def register(cli):
    """ Register new CLI nodes in root CLI.

    Args:
        cli: Root CLI node.
    Raises:
        Exception: when root CLI already has a command
                   we are trying to register.
    """
    cli_node = DHCPV4_RELAY
    if cli_node.name in cli.commands:
        raise Exception(f"{cli_node.name} already exists in CLI")
    cli.add_command(DHCPV4_RELAY)
