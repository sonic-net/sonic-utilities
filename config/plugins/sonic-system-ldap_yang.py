"""
Autogenerated config CLI plugin.


"""

import copy
import click
import utilities_common.cli as clicommon
import utilities_common.general as general
from config import config_mgmt

# Load sonic-cfggen from source since /usr/local/bin/sonic-cfggen does not have .py extension.
sonic_cfggen = general.load_module_from_source('sonic_cfggen', '/usr/local/bin/sonic-cfggen')


def exit_with_error(*args, **kwargs):
    """ Print a message with click.secho and abort CLI.

    Args:
        args: Positional arguments to pass to click.secho
        kwargs: Keyword arguments to pass to click.secho
    """

    click.secho(*args, **kwargs)
    raise click.Abort()


def validate_config_or_raise(cfg):
    """ Validate config db data using ConfigMgmt.

    Args:
        cfg (Dict): Config DB data to validate.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    try:
        cfg = sonic_cfggen.FormatConverter.to_serialized(copy.deepcopy(cfg))
        config_mgmt.ConfigMgmt().loadData(cfg)
    except Exception as err:
        raise Exception('Failed to validate configuration: {}'.format(err))


def add_entry_validated(db, table, key, data):
    """ Add new entry in table and validate configuration.

    Args:
        db (swsscommon.ConfigDBConnector): Config DB connector obect.
        table (str): Table name to add new entry to.
        key (Union[str, Tuple]): Key name in the table.
        data (Dict): Entry data.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    cfg = db.get_config()
    cfg.setdefault(table, {})
    if key in cfg[table]:
        raise Exception(f"{key} already exists")

    cfg[table][key] = data

    validate_config_or_raise(cfg)
    db.set_entry(table, key, data)


def update_entry_validated(db, table, key, data, create_if_not_exists=False):
    """ Update entry in table and validate configuration.
    If attribute value in data is None, the attribute is deleted.

    Args:
        db (swsscommon.ConfigDBConnector): Config DB connector obect.
        table (str): Table name to add new entry to.
        key (Union[str, Tuple]): Key name in the table.
        data (Dict): Entry data.
        create_if_not_exists (bool):
            In case entry does not exists already a new entry
            is not created if this flag is set to False and
            creates a new entry if flag is set to True.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    cfg = db.get_config()
    cfg.setdefault(table, {})

    if not data:
        raise Exception(f"No field/values to update {key}")

    if create_if_not_exists:
        cfg[table].setdefault(key, {})

    if key not in cfg[table]:
        raise Exception(f"{key} does not exist")

    entry_changed = False
    for attr, value in data.items():
        if value == cfg[table][key].get(attr):
            continue
        entry_changed = True
        if value is None:
            cfg[table][key].pop(attr, None)
        else:
            cfg[table][key][attr] = value

    if not entry_changed:
        return

    validate_config_or_raise(cfg)
    db.set_entry(table, key, cfg[table][key])


def del_entry_validated(db, table, key):
    """ Delete entry in table and validate configuration.

    Args:
        db (swsscommon.ConfigDBConnector): Config DB connector obect.
        table (str): Table name to add new entry to.
        key (Union[str, Tuple]): Key name in the table.
    Raises:
        Exception: when cfg does not satisfy YANG schema.
    """

    cfg = db.get_config()
    cfg.setdefault(table, {})
    if key not in cfg[table]:
        raise Exception(f"{key} does not exist")

    cfg[table].pop(key)

    validate_config_or_raise(cfg)
    db.set_entry(table, key, None)


@click.group(name="ldap-server",
             cls=clicommon.AliasedGroup)
def LDAP_SERVER():
    """  """

    pass


@LDAP_SERVER.command(name="add")
@click.argument(
    "hostname",
    nargs=1,
    required=True,
)
@click.option(
    "--priority",
    help="Server priority",
)
@clicommon.pass_db
def LDAP_SERVER_add(db, hostname, priority):
    """ Add object in LDAP_SERVER. """

    table = "LDAP_SERVER"
    key = hostname
    data = {}
    if priority is not None:
        data["priority"] = priority

    try:
        add_entry_validated(db.cfgdb, table, key, data)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@LDAP_SERVER.command(name="update")
@click.argument(
    "hostname",
    nargs=1,
    required=True,
)
@click.option(
    "--priority",
    help="Server priority",
)
@clicommon.pass_db
def LDAP_SERVER_update(db, hostname, priority):
    """ Add object in LDAP_SERVER. """

    table = "LDAP_SERVER"
    key = hostname
    data = {}
    if priority is not None:
        data["priority"] = priority

    try:
        update_entry_validated(db.cfgdb, table, key, data)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@LDAP_SERVER.command(name="delete")
@click.argument(
    "hostname",
    nargs=1,
    required=True,
)
@clicommon.pass_db
def LDAP_SERVER_delete(db, hostname):
    """ Delete object in LDAP_SERVER. """

    table = "LDAP_SERVER"
    key = hostname
    try:
        del_entry_validated(db.cfgdb, table, key)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@click.group(name="ldap",
             cls=clicommon.AliasedGroup)
def LDAP():
    """  """

    pass


@LDAP.group(name="global", cls=clicommon.AliasedGroup)
@clicommon.pass_db
def LDAP_global(db):
    """  """

    pass


@LDAP_global.command(name="bind-dn")
@click.argument(
    "bind-dn",
    nargs=1,
    required=True,
)
@clicommon.pass_db
def LDAP_global_bind_dn(db, bind_dn):
    """ LDAP global bind dn """

    table = "LDAP"
    key = "global"
    data = {
        "bind_dn": bind_dn,
    }
    try:
        update_entry_validated(db.cfgdb, table, key, data, create_if_not_exists=True)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@LDAP_global.command(name="bind-password")
@click.argument(
    "bind-password",
    nargs=1,
    required=True,
)
@clicommon.pass_db
def LDAP_global_bind_password(db, bind_password):
    """ Shared secret used for encrypting the communication """

    table = "LDAP"
    key = "global"
    data = {
        "bind_password": bind_password,
    }
    try:
        update_entry_validated(db.cfgdb, table, key, data, create_if_not_exists=True)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@LDAP_global.command(name="bind-timeout")
@click.argument(
    "bind-timeout",
    nargs=1,
    required=True,
)
@clicommon.pass_db
def LDAP_global_bind_timeout(db, bind_timeout):
    """ Ldap bind timeout """

    table = "LDAP"
    key = "global"
    data = {
        "bind_timeout": bind_timeout,
    }
    try:
        update_entry_validated(db.cfgdb, table, key, data, create_if_not_exists=True)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@LDAP_global.command(name="version")
@click.argument(
    "version",
    nargs=1,
    required=True,
)
@clicommon.pass_db
def LDAP_global_version(db, version):
    """ Ldap version """

    table = "LDAP"
    key = "global"
    data = {
        "version": version,
    }
    try:
        update_entry_validated(db.cfgdb, table, key, data, create_if_not_exists=True)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@LDAP_global.command(name="base-dn")
@click.argument(
    "base-dn",
    nargs=1,
    required=True,
)
@clicommon.pass_db
def LDAP_global_base_dn(db, base_dn):
    """ Ldap user base dn """

    table = "LDAP"
    key = "global"
    data = {
        "base_dn": base_dn,
    }
    try:
        update_entry_validated(db.cfgdb, table, key, data, create_if_not_exists=True)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@LDAP_global.command(name="port")
@click.argument(
    "port",
    nargs=1,
    required=True,
)
@clicommon.pass_db
def LDAP_global_port(db, port):
    """ TCP port to communicate with LDAP server """

    table = "LDAP"
    key = "global"
    data = {
        "port": port,
    }
    try:
        update_entry_validated(db.cfgdb, table, key, data, create_if_not_exists=True)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


@LDAP_global.command(name="timeout")
@click.argument(
    "timeout",
    nargs=1,
    required=True,
)
@clicommon.pass_db
def LDAP_global_timeout(db, timeout):
    """ Ldap timeout duration in sec """

    table = "LDAP"
    key = "global"
    data = {
        "timeout": timeout,
    }
    try:
        update_entry_validated(db.cfgdb, table, key, data, create_if_not_exists=True)
    except Exception as err:
        exit_with_error(f"Error: {err}", fg="red")


def register(cli):
    """ Register new CLI nodes in root CLI.

    Args:
        cli: Root CLI node.
    Raises:
        Exception: when root CLI already has a command
                   we are trying to register.
    """
    cli_node = LDAP_SERVER
    if cli_node.name in cli.commands:
        raise Exception(f"{cli_node.name} already exists in CLI")
    cli.add_command(LDAP_SERVER)
    cli_node = LDAP
    if cli_node.name in cli.commands:
        raise Exception(f"{cli_node.name} already exists in CLI")
    cli.add_command(LDAP)
